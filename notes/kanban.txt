##########################################################
# Release 1.0.0
##########################################################

* initial write-up document
  • basic description of "A block-based genetic algorithm time-series forecasting graph processor"

* initialize kgraph and validate connection

* load initial linear test data case
  • linear ascending values for the nodes in a linear path
  • nodes and edges contain time values
  
* create graphs for both data and for the garden.

* create initial thought

* have goal location represented in graph distance.

* create initial fitness function

* ponder the value of predicting the past ("backcasting")

* create initial garden

* create a thought process (see also: https://github.com/seratch/antlr-maven-example )
  • identify a good example of what a thought should do (good initial example)
  • generate initial thought process design (design approach)
  • add build and test - buildThought()
  
* develop sequencing to process a thought - getOperationsByMaxLayer()

* run a thought and measure the result against the goal

* Make a scoring machine and score the thoughts for a goal.

* break the classes into different packages

* offspring generator - clone thought

* offspring generator - make mutations from a clone of a parent thought

* offspring generator - merge two thoughts (crossover)

* offspring generator - merge two merged thoughts

* export a thought to JSON

* export a thought as Dot.

* import a thought from JSON

* load large dataset (the first 3 of the "A" set.)

* profile and speed up

* get datasets
  - fetch and load the VIX (see: https://en.wikipedia.org/wiki/VIX)
  - fetch and load the Wilshire 5000 (see: https://en.wikipedia.org/wiki/Wilshire_5000)
  - fetch and load US GDP

##########################################################
# WIP
##########################################################

* thought modeling: diagram -> XML -> kgraph

* build seed thought - stock price linear growth

* build seed thought - VIX influences future stock price

* create ProfitThoughtGenerator

##########################################################
# functional backlog
##########################################################



* build seed thought - Buffett Indicator detirmines future stock price

* Have thoughts indicate level of certainty (proposed weight)

* build evolution example. Given:
  - history of a stock (linear)
  - VIX causes push up or down
  - Buffett Indicator (wilshire 5000/US GDP X 100) causes push up or down
  - US GDP grows at 8%
  Show evolution of solution accuracy.
  - play with future distances
  - play with sum of fear and greed
  - play with Buffett Indicator

* get datasets
  - load the Buffett Indicator (how?)
  - load all A's
  - fetch all stock symbols
  - load all stock symbols
  - fetch and load Nasdaq 100
  - fetch and load S&P 500
  - fetch and load DJIA (what is this?)
  - fetch and load Russell 2000
  - Commodies information?
  - sentiment analysis info?
  - GDP by industry? (see: https://www.bea.gov/resources/learning-center/what-to-know-gdp)


* create initial offspring generator
  - framework for creating offspring with mutation and crossover

* support genetic operations on offspring generators

* add README content: * genetic algorithm:

* add README content for "the garden"

* add README content: * time-series:

* add README content: * forecasting:

* add README content: * graph processing:

* add README content: ## Motivations

* add README content: ### Under-Researched Areas

* add README content: ### Interactive Capable

* README content for composition of genetic solution solutions from genetic solutions.

* create a median merge from a set of neighbor averaging nodes (mutation)

* create a 'change node type' argument mutation

* create a 'change edge type' argument mutation

* sanitize - whelanlabs -> blackwalnutsoftware, strip: "john", "whelan", other?

##########################################################
# performance backlog
##########################################################

* go through code, identify each for loop, and consider parallel processing it using a reusable thread pool.
  (limit the total number of threads...)  This is likely to result in multiple work items.
  
* speed up unit tests by reducing the number of flushes necessary.


